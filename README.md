# Irteya Test

## Задание 1 Конструктор формы на React с использованием `react-hook-form`, `zod`, Ant Design и Tailwind CSS.

## Стек технологий

-   **React 18**
-   **TypeScript**
-   **Vite**
-   **react-hook-form** + **zod** (валидация)
-   **Ant Design v5**
-   **Tailwind CSS**

---

## Установка и запуск

1. **Клонировать репозиторий**

```bash
git clone https://github.com/Daminogs/irteya-test
cd irteya-test
```

2. **Установить зависимости**

```bash
npm install
```

3. **Запустить в режиме разработки**

```bash
npm run dev
```

Открой в браузере [http://localhost:5173](http://localhost:5173)

4. **Собрать проект**

```bash
npm run build
```

5. **Предпросмотр собранной версии**

```bash
npm run preview
```

---

## Как проверить проект

1. После запуска (`npm run dev`) в браузере откроется форма.
2. Заполни поля формы:
    - Адрес, город, штат, пол
    - Телефоны (динамические поля)
    - Родители (динамические карточки с полями)
3. Попробуй добавить и удалить элементы массива.
4. Нажми кнопку **"Отправить"** — в консоли браузера появятся отправленные данные.
5. Проверь, что валидация срабатывает (например, оставь поле пустым).

---

## Скрипты

-   `npm run dev` — запуск в dev-режиме
-   `npm run build` — сборка проекта
-   `npm run preview` — предпросмотр production-сборки
-   `npm run lint` — проверка кода линтером

---

## Задание 2 DSL для дашборда

DSL описывает структуру дашборда: параметры сетки (resolution), секции (sections) и графики (charts).
Каждый график содержит название (title), тип (type: linear, area, bar), цветовую схему (colorScheme), метрики (metrics) и размеры (width, height).

Файлы:

Типы DSL — src/types/dsl.ts

Пример DSL — src/shared/fixtures/Dsl-task/dsl.example.json

---

## Задание 3 Подсчет совпадений в массивах

Решение находится рядом с src в папке count-matches. Для проверки вывода можно посмотреть в консоль браузера.
В этой задаче я пошёл по пути, который даёт максимально быстрый и экономичный результат.
Сначала я пробегаюсь по массиву B и считаю, сколько раз встречается каждое значение, сохраняя результат в Map — это быстро (доступ за O(1)) и не требует лишних преобразований.
Дальше из массива A делаю Set, чтобы избавиться от повторов, и просто для каждого уникального элемента заглядываю в Map, забирая готовый подсчёт.
Алгоритм работает за O(N + M), то есть линейно от размеров массивов, и использует минимум памяти — только под два набора уникальных значений.
На массивах в миллион элементов он отрабатывает за несколько десятков миллисекунд, так что с производительностью всё отлично.